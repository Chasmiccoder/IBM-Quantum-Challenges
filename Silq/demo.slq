// Demo from "Silq: High-Level Quantum Programming | Qiskit Seminar Series with Benjamin Bichsel", https://www.youtube.com/watch?v=I8MqcP2Q_Kw

// === Measurement ===

// measure is a function that is not mfree
// basically, you cannot undo a measurement
// error recognized: reversed function must be mfree
def reverse_measurement(){
    return reverse(measure);
}

// Try to hide a measurement and make it look it the function is 'reversible'
// passing a function that is not mfree 
// error recognized: reversed function must be mfree
def reverse_f(f:ð”¹ !â†’ ð”¹){
    return reverse(f);
}

// this function tries to hide a measurement
// silq recognizes this
def hide_measurement(q:ð”¹){
    measure(q);
    return 0:ð”¹;
}

def reverse_hidden_measurement(){
    reverse_f(hide_measurement);
}

// proper way to specify that a function is mfree
def reverse_f2(f:ð”¹ !â†’ mfree ð”¹){
    return reverse(f);
}

// â†’ means that we have a function
// !â†’ means that the function is classically known

// if qubit c is 1, then measure qubit q
// this doesn't work because if c is a qubit, we'll have to measure it to figure out if it is 1
// cannot call function 'measure[ð”¹]' in 'mfree' context
def conditional_measurement(const c:ð”¹, q:ð”¹){
    if c{
        q := measure(q);
    }
    return q;
}

// proper way of doing the above - mention that c is classical
def conditional_measurement2(const c:!ð”¹, q:ð”¹){
    if c{
        q := measure(q);
    }
    return q;
}

// === Linear Type Systems ===

// error recognized: parameter 's' is not consumed
def implicit_measurement[n:!â„•](s:uint[n]){
    // say s holds the unsigned integer 7
    t := s % 2;
    // t is now |1>
    // the system itself is in |7>â‚› âŠ— |1>â‚œ

    return t;
}

// we need to specify that s will remain unchanged
def implicit_measurement2[n:!â„•](const s:uint[n]){
    t := s % 2;
    return t;
}

// error recognized: undefined identifier s
def use_consumed(s:ð”¹){
    // say s is |0>
    t := H(s);
    // now s is |+>
    return (s,t);
}

// one way of fixing the above
def use_consumed_dup(s:ð”¹){
    // say s is |0>
    x := dup(s);
    // now the system is in |0>â‚› âŠ— |0>â‚œ
    t := H(x);
    // now the system is in |0>â‚› âŠ— |+>â‚œ
    return (s,t);
}

// another way of fixing the above
// if you annotate s as const, then silq will do this implicitly
def use_consumed_implicit_dup(const s:ð”¹){
    // the system is in |0>â‚›
    t := H(s);
    // now the system is in |0>â‚› âŠ— |+>â‚œ
    return t;
}

// you can explicitly specify the return type
def f1(const s:ð”¹):ð”¹{
    t := H(s);
    return t;
}

// when the return data contains qubit and classical data
def f2(const s:ð”¹):ð”¹ x (!ð”¹){
    t := H(s);
    return t; // error: ð”¹ is incompatible with return type ð”¹ Ã— !ð”¹
}

// === Uncomputation ===

// with lifted, all args are implicitly const
def my_or(s:ð”¹, t:ð”¹)lifted{
    // |0>â‚› âŠ— |0>â‚œ
    return ! (!s && !t);
    // |0>â‚› âŠ— |1>â‚œ âŠ— |1>
}

/*
How Temporary Values are handled (Uncomputation)

OR of 3 variables

Initially, the system is in |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ
s := (x || a) || t;
Now the system is in |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ âŠ— |1>â‚›

How this works internally

Initial state: |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ
To perform x || a, we need 1 ancilla qubit
Apply U_or to the qubits x and a, with ancilla e
The system will then go to |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ âŠ— |1>â‚‘
Where the subscript e is the qubit that stores x || a

Then we introduce one more qubit s, to store the final result e || t
Apply U_or to the qubits e and t, with ancilla s
The system will then go to |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ âŠ— |1>â‚‘ âŠ— |1>â‚›

Now we have an extra qubit e, which was used as a temporary variable
We need to uncompute this qubit, as directly measuring it will collapse the superposition
We can do this by applying the adjoint of U_or on qubits x, a, and e
Then the system will go to |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ âŠ— |0>â‚‘ âŠ— |1>â‚›
Now we can safely measure e to get the needed result |0>â‚“ âŠ— |1>â‚  âŠ— |0>â‚œ âŠ— |1>â‚›

This whole thing can be summarized as -
s := (x || a) || t;
is,
e := x || a;
s:= e || t;
forget(e);

*/


def overwrite(const s:ð”¹, const t:ð”¹){
    // |0>â‚› âŠ— |1>â‚œ
    u := s || t;

    // |0>â‚› âŠ— |1>â‚œ âŠ— |1>áµ¤
    u = 0:ð”¹;  // implicitly uncomputes old values of u
    
    // |0>â‚› âŠ— |1>â‚œ âŠ— |0>áµ¤
    return u;
}

// example where uncomputation does not work
// error recognized: cannot synthesize forget expression for 't'
// If we forget t, then we would have consumed s for no reason
// the final state would be empty (i.e, no state), even though we didn't measure s

def uncompute_non_const(s:ð”¹){
    // |0>â‚› + |1>â‚›
    t := X(s);
    // |1>â‚œ + |0>â‚œ
    forget(t);
    // (empty)
}

// to fix the above,
// this works because s is still around for uncomputation
def uncompute_non_const_dup(s:ð”¹){
    // |0>â‚› + |1>â‚›
    t := X(dup(s));
    // |0>â‚› âŠ— |1>â‚œ + |1>â‚› âŠ— |0>â‚œ
    forget(t);
    // |0>â‚› + |1>â‚›
    return s;
}

// Uncompute a non qfree expression
// error recognized: cannot synthesize forget expression for 't'
def uncomput_non_qfree(s:ð”¹){
    // |1>â‚›
    t := H(dup(s));
    // |1>â‚› âŠ— |->â‚œ = |1>â‚› âŠ— |0>â‚œ - |1>â‚› âŠ— |1>â‚œ
    forget(t);
    // |1>â‚› - |1>â‚› = 0 (state with norm 0)
    // it's not clear what should happen here
    return s;
}


